<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>リンクINDEX</title>
  <link rel="icon" href="data:,"><!-- favicon 404対策 -->
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 24px; }
    header { display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    h1 { margin:0; font-size:28px; }
    .muted { opacity:.7; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .card { border:1px solid #ddd; border-radius:12px; padding:14px; margin:12px 0; background:#fff; }
    .grid { display:grid; grid-template-columns: 1fr; gap:10px; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1fr 1fr; } }
    input, select, button { padding:10px; border-radius:10px; border:1px solid #ccc; }
    button { cursor:pointer; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .tag { display:inline-block; padding:2px 10px; border:1px solid #ccc; border-radius:999px; font-size:12px; margin-left:8px; }
    .item { border:1px solid #eee; border-radius:12px; padding:12px; }
    .item h3 { margin:0 0 6px; font-size:16px; }
    .item a { text-decoration:none; }
    .item small { display:block; margin-top:6px; }
    .admin { background:#fafafa; }
    .danger { border-color:#e7b3b3; background:#fff7f7; }
    .hidden { display:none !important; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid #ddd; background:#f6f6f6; font-size:12px; }
    .switch { display:inline-flex; align-items:center; gap:8px; user-select:none; }
    .switch input { width:18px; height:18px; }
    #diag { white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>リンクINDEX</h1>
      <div class="muted" id="subtitle">公開ONのリンクは、ログインしていない状態でも閲覧できます</div>
    </div>

    <div class="row">
      <button id="reloadBtn">再読み込み</button>
      <button id="loginBtn">管理者ログイン</button>
      <button id="logoutBtn" class="hidden">ログアウト</button>
    </div>
  </header>

  <section id="controlsCard" class="card">
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <input id="q" placeholder="検索（タイトル/パス）" />
        <select id="catFilter">
          <option value="">カテゴリ（すべて）</option>
        </select>
      </div>
      <div class="row">
        <span class="pill">取得元: <code id="sourceLabel"></code></span>
        <span class="pill">件数: <strong id="countLabel">-</strong></span>
        <span class="pill">最終更新: <span id="updatedLabel">-</span></span>
      </div>
    </div>
    <div id="notice" class="muted" style="margin-top:10px;"></div>
  </section>

  <section id="publicLocked" class="card">
    <div><strong>閲覧について</strong></div>
    <div class="muted" style="margin-top:6px;">
      公開ONのリンクだけを表示します。管理者はログインすると公開/非公開の切り替え、タイトル・カテゴリ編集、単体保存/一括保存ができます。
    </div>
  </section>

  <section id="statusCard" class="card">
    <div id="statusText">待機中</div>
  </section>

  <section id="adminPanel" class="card admin hidden">
    <h2 style="margin:0 0 10px;">管理者パネル</h2>

    <div id="loginBox" class="grid">
      <div class="item">
        <h3>ログイン（メール/パスワード）</h3>
        <div class="row">
          <input id="email" type="email" placeholder="email" style="min-width:240px;">
          <input id="pass" type="password" placeholder="password" style="min-width:240px;">
          <button id="doLogin">ログイン</button>
        </div>
        <div id="authMsg" class="muted" style="margin-top:8px;"></div>
      </div>

      <div class="item danger">
        <h3>初回だけ：管理者ユーザーを作成</h3>
        <div class="row">
          <input id="newEmail" type="email" placeholder="admin email" style="min-width:240px;">
          <input id="newPass" type="password" placeholder="admin password" style="min-width:240px;">
          <button id="doCreateUser">管理者作成</button>
        </div>
        <small class="muted">公開前にこの機能は削除推奨。</small>
        <div id="createMsg" class="muted" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="editorBox" class="hidden">
      <div class="row" style="margin-bottom:10px;">
        <span>ログイン中: <strong id="userLabel"></strong></span>
        <span class="muted">（編集内容はFirestoreに保存）</span>
      </div>

      <div class="row" style="margin:10px 0;">
        <button id="saveAllBtn">一括保存</button>
        <span id="saveAllMsg" class="muted"></span>
      </div>

      <div class="muted">
        ※ Firestore が広告ブロッカー等でブロックされている環境では、保存/読み込みが失敗します（ConsoleにERR_BLOCKED_BY_CLIENTが出ます）。
      </div>
    </div>
  </section>

  <section id="list" class="grid"></section>

  <section class="card hidden" id="diag"></section>

  <script type="module">
    /********************
     * 0) 設定
     ********************/
    const CFG = {
      github: {
        owner: "DrPotter2022",
        repo: "call-link-test",
        branch: "main",
        path: "",
        includeExt: [".html", ".pdf"],
        siteBaseUrl: "https://drpotter2022.github.io/call-link-test/"
      },
      firebase: {
        apiKey: "AIzaSyCJV2CDJl9NW6Qz3sbPd8nrV0zevzZam0I",
        authDomain: "index-6c554.firebaseapp.com",
        projectId: "index-6c554",
      },
      collection: "link_index_meta_v1",
      debug: false
    };

    /********************
     * helpers
     ********************/
    const el = (id) => document.getElementById(id);
    const listEl = el("list");
    const qEl = el("q");
    const catFilterEl = el("catFilter");
    const reloadBtn = el("reloadBtn");
    const loginBtn = el("loginBtn");
    const logoutBtn = el("logoutBtn");
    const noticeEl = el("notice");
    const statusText = el("statusText");
    const adminPanel = el("adminPanel");
    const loginBox = el("loginBox");
    const editorBox = el("editorBox");
    const userLabel = el("userLabel");
    const saveAllBtn = el("saveAllBtn");
    const saveAllMsg = el("saveAllMsg");
    const diagEl = el("diag");

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (m) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[m]));
    }

    function diag(msg) {
      if (!CFG.debug) return;
      diagEl.classList.remove("hidden");
      diagEl.textContent += msg + "\n";
    }

    function setStatus(msg) {
      statusText.textContent = msg;
    }

    function shouldInclude(filePath) {
      const p = filePath.split(/[?#]/)[0];
      return /\.(html|pdf)$/i.test(p);
    }

    function defaultTitleFromPath(p) {
      const name = p.split("/").pop() || p;
      return decodeURIComponent(name)
        .replace(/\.[^/.]+$/, "")
        .replace(/[_-]+/g, " ");
    }

    function buildUrl(filePath) {
      return CFG.github.siteBaseUrl.replace(/\/$/, "/") + filePath;
    }

    function metaDocId(filePath) {
      return filePath.replaceAll("/", "__");
    }

    /********************
     * 1) Firebase
     ********************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import {
      getAuth, onAuthStateChanged,
      signInWithEmailAndPassword, signOut,
      createUserWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import {
      getFirestore, collection, doc, setDoc,
      getDocs, query, where, documentId, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    const app = initializeApp(CFG.firebase);
    const auth = getAuth(app);
    const db = getFirestore(app);

    async function saveMeta(path, meta) {
      const ref = doc(db, CFG.collection, metaDocId(path));
      await setDoc(ref, { ...meta, path, updatedAt: serverTimestamp() }, { merge: true });
    }

    /********************
     * 2) GitHub Tree
     ********************/
    async function fetchGitHubTree() {
      const { owner, repo, branch, path } = CFG.github;

      const refUrl = `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${branch}`;
      const refRes = await fetch(refUrl);
      if (!refRes.ok) throw new Error("GitHub ref取得に失敗: " + refRes.status);
      const refJson = await refRes.json();

      const commitRes = await fetch(refJson.object.url);
      if (!commitRes.ok) throw new Error("GitHub commit取得に失敗: " + commitRes.status);
      const commitJson = await commitRes.json();
      const treeSha = commitJson.tree.sha;

      const treeRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${treeSha}?recursive=1`);
      if (!treeRes.ok) throw new Error("GitHub tree取得に失敗: " + treeRes.status);
      const treeJson = await treeRes.json();

      const base = (path || "").replace(/\/$/, "");
      const prefix = base ? (base + "/") : "";

      return treeJson.tree
        .filter(x => x.type === "blob" && x.path.startsWith(prefix))
        .map(x => ({ path: x.path, size: x.size ?? null }));
    }

    /********************
     * 3) Firestore Meta バッチ取得（高速化）
     ********************/
    async function fetchMetaMapForAdmin(docIds) {
      const map = new Map();
      const colRef = collection(db, CFG.collection);

      for (let i = 0; i < docIds.length; i += 30) {
        const chunk = docIds.slice(i, i + 30);
        const qy = query(colRef, where(documentId(), "in", chunk));
        const snap = await getDocs(qy);
        snap.forEach(d => map.set(d.id, d.data()));
      }
      return map;
    }

    async function fetchPublicMetaMap() {
      const map = new Map();
      const colRef = collection(db, CFG.collection);
      const qy = query(colRef, where("public", "==", true));
      const snap = await getDocs(qy);
      snap.forEach(d => map.set(d.id, d.data()));
      return map;
    }

    /********************
     * 4) 描画
     ********************/
    let isAdmin = false;
    let items = [];

    function upsertCategoryOptions(categories) {
      const current = catFilterEl.value;
      catFilterEl.innerHTML = `<option value="">カテゴリ（すべて）</option>` +
        [...categories].sort().map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("");
      catFilterEl.value = current;
    }

    function rebuildCategoryList() {
      const cats = new Set();
      items.forEach(x => { if (x.category) cats.add(x.category); });
      upsertCategoryOptions(cats);
    }

    function renderItemCard(x) {
      const tag = x.category ? `<span class="tag">${escapeHtml(x.category)}</span>` : "";
      const publicPill = x.public ? `<span class="pill">公開ON</span>` : `<span class="pill">公開OFF</span>`;

      const adminControls = isAdmin ? `
        <div class="row" style="margin-top:10px;">
          <label class="switch">
            <input type="checkbox" data-k="public" data-path="${escapeHtml(x.path)}" ${x.public ? "checked":""}>
            公開
          </label>
          <input data-k="title" data-path="${escapeHtml(x.path)}" value="${escapeHtml(x.title)}" placeholder="表示名" style="min-width:220px;">
          <input data-k="category" data-path="${escapeHtml(x.path)}" value="${escapeHtml(x.category ?? "")}" placeholder="カテゴリ" style="min-width:160px;">
          <input data-k="order" data-path="${escapeHtml(x.path)}" value="${escapeHtml(x.order ?? "")}" placeholder="表示順(数字)" style="width:140px;">
          <button data-act="save" data-path="${escapeHtml(x.path)}">保存</button>
        </div>
      ` : "";

      return `
        <div class="item">
          <h3>
            <a href="${escapeHtml(x.url)}" target="_blank" rel="noopener">${escapeHtml(x.title)}</a>
            ${tag}
          </h3>
          <small class="muted">${escapeHtml(x.path)} ${!isAdmin ? publicPill : ""}</small>
          ${adminControls}
        </div>
      `;
    }

    function applyFiltersAndRender() {
      const q = qEl.value.trim().toLowerCase();
      const cat = catFilterEl.value;

      const filtered = items
        .filter(x => isAdmin ? true : !!x.public)
        .filter(x => !q || (x.title.toLowerCase().includes(q) || x.path.toLowerCase().includes(q)))
        .filter(x => !cat || x.category === cat)
        .sort((a,b) => (a.order ?? 9999) - (b.order ?? 9999) || a.title.localeCompare(b.title,"ja"));

      el("countLabel").textContent = String(filtered.length);
      listEl.innerHTML = filtered.map(x => renderItemCard(x)).join("");

      if (isAdmin) bindAdminControls();
    }

    /********************
     * 5) 保存処理を共通化（単体/一括）
     ********************/
    function readMetaFromCard(wrap) {
      const anyPathEl = wrap.querySelector('[data-path]');
      const path = anyPathEl?.getAttribute("data-path");
      if (!path) return { ok:false, error:"path not found" };

      const title = wrap.querySelector(`input[data-k="title"]`)?.value.trim() ?? "";
      const category = wrap.querySelector(`input[data-k="category"]`)?.value.trim() ?? "";
      const orderRaw = wrap.querySelector(`input[data-k="order"]`)?.value.trim() ?? "";
      const isPublic = !!wrap.querySelector(`input[type="checkbox"][data-k="public"]`)?.checked;

      const order = orderRaw === "" ? null : Number(orderRaw);
      if (orderRaw !== "" && Number.isNaN(order)) {
        return { ok:false, error:"表示順は数字で入力してください", path };
      }

      return {
        ok: true,
        path,
        meta: {
          public: isPublic,
          title: title || defaultTitleFromPath(path),
          category: category || null,
          order
        }
      };
    }

    async function persistOne(path, meta) {
      await saveMeta(path, meta);

      const idx = items.findIndex(x => x.path === path);
      if (idx >= 0) {
        items[idx].public = !!meta.public;
        items[idx].title = meta.title ?? items[idx].title;
        items[idx].category = meta.category ?? null;
        items[idx].order = meta.order ?? null;
      }
    }

    function bindAdminControls() {
      // 単体保存
      listEl.querySelectorAll('button[data-act="save"]').forEach(btn => {
        if (btn.dataset.bound === "1") return;
        btn.dataset.bound = "1";

        btn.addEventListener("click", async () => {
          const wrap = btn.closest(".item");
          const r = readMetaFromCard(wrap);
          if (!r.ok) { alert(r.error); return; }

          btn.disabled = true;
          const oldText = btn.textContent;
          btn.textContent = "保存中…";
          try {
            await persistOne(r.path, r.meta);
            rebuildCategoryList();
            applyFiltersAndRender();
            alert("保存しました");
          } catch (e) {
            console.error(e);
            alert("保存失敗（Firestoreがブロックされている可能性大）:\n" + (e?.message ?? e));
          } finally {
            btn.disabled = false;
            btn.textContent = oldText;
          }
        });
      });

      // 一括保存
      if (!saveAllBtn.dataset.bound) {
        saveAllBtn.dataset.bound = "1";
        saveAllBtn.addEventListener("click", async () => {
          const cards = [...listEl.querySelectorAll(".item")];
          saveAllBtn.disabled = true;
          saveAllMsg.textContent = "一括保存中…";

          let ok = 0, ng = 0;
          for (const wrap of cards) {
            const r = readMetaFromCard(wrap);
            if (!r.ok) { ng++; continue; }
            try {
              await persistOne(r.path, r.meta);
              ok++;
            } catch (e) {
              console.error(e);
              ng++;
            }
          }
          rebuildCategoryList();
          applyFiltersAndRender();

          saveAllBtn.disabled = false;
          saveAllMsg.textContent = `完了：成功 ${ok} / 失敗 ${ng}`;
          alert(`一括保存：成功 ${ok} / 失敗 ${ng}\n（ブロックされていると失敗します）`);
        });
      }
    }

    /********************
     * 6) 画面制御（ログイン前後）
     ********************/
    function showAdminUI(user) {
      isAdmin = !!user;
      if (user) {
        loginBox.classList.add("hidden");
        editorBox.classList.remove("hidden");
        userLabel.textContent = user.email || "(unknown)";
        logoutBtn.classList.remove("hidden");
      } else {
        loginBox.classList.remove("hidden");
        editorBox.classList.add("hidden");
        userLabel.textContent = "";
        logoutBtn.classList.add("hidden");
      }
    }

    loginBtn.addEventListener("click", () => {
      adminPanel.classList.toggle("hidden");
      if (!adminPanel.classList.contains("hidden")) {
        adminPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });

    logoutBtn.addEventListener("click", async () => {
      await signOut(auth);
    });

    el("doLogin").addEventListener("click", async () => {
      try {
        el("authMsg").textContent = "ログイン中…";
        await signInWithEmailAndPassword(auth, el("email").value, el("pass").value);
        el("authMsg").textContent = "";
      } catch (e) {
        el("authMsg").textContent = "ログイン失敗: " + (e?.message ?? e);
      }
    });

    el("doCreateUser").addEventListener("click", async () => {
      try {
        el("createMsg").textContent = "作成中…";
        await createUserWithEmailAndPassword(auth, el("newEmail").value, el("newPass").value);
        el("createMsg").textContent = "管理者ユーザーを作成しました（公開前に削除推奨）";
      } catch (e) {
        el("createMsg").textContent = "作成失敗: " + (e?.message ?? e);
      }
    });

    /********************
     * 7) 読み込み
     ********************/
    el("sourceLabel").textContent = `github:${CFG.github.owner}/${CFG.github.repo}/${CFG.github.branch}/${CFG.github.path}`;

    async function loadAll() {
      noticeEl.textContent = "";
      setStatus("読み込み中…");
      el("updatedLabel").textContent = new Date().toLocaleString("ja-JP");

      // 1) GitHub
      const raw = await fetchGitHubTree();
      const files = raw.filter(x => shouldInclude(x.path));
      diag("GitHub tree blobs = " + raw.length);
      diag("after ext filter = " + files.length);

      // 2) まずitemsを作る（metaなし）
      const base = files.map(f => ({
        path: f.path,
        url: buildUrl(f.path),
        title: defaultTitleFromPath(f.path),
        category: null,
        order: null,
        public: false
      }));

      // 3) Firestore meta をまとめて引く（失敗したら即諦める＝待たない）
      let metaMap = new Map();
      try {
        if (isAdmin) {
          const docIds = base.map(x => metaDocId(x.path));
          metaMap = await fetchMetaMapForAdmin(docIds);
        } else {
          metaMap = await fetchPublicMetaMap();
        }
      } catch (e) {
        console.warn("meta fetch failed:", e);
        noticeEl.textContent = "※ Firestore がブロックされている環境では、公開ON/OFFの判定や保存が失敗します（広告ブロッカー等をOFFにしてください）。";
        if (!isAdmin) {
          items = [];
          rebuildCategoryList();
          applyFiltersAndRender();
          setStatus("Firestoreに接続できないため、公開リンクを取得できません。");
          return;
        }
      }

      // 4) merge
      items = base.map(x => {
        const md = metaMap.get(metaDocId(x.path)) || null;
        return {
          ...x,
          title: md?.title ?? x.title,
          category: md?.category ?? x.category,
          order: md?.order ?? x.order,
          public: md?.public ?? x.public
        };
      });

      rebuildCategoryList();
      applyFiltersAndRender();
      setStatus("完了");
    }

    reloadBtn.addEventListener("click", () => loadAll().catch(err => {
      console.error(err);
      setStatus("エラー: " + (err?.message ?? err));
    }));

    qEl.addEventListener("input", applyFiltersAndRender);
    catFilterEl.addEventListener("change", applyFiltersAndRender);

    onAuthStateChanged(auth, async (user) => {
      showAdminUI(user);
      try {
        await loadAll();
      } catch (e) {
        console.error(e);
        setStatus("エラー: " + (e?.message ?? e));
      }
    });

    // 初回表示（未ログインでも公開ONを見せたい）
    loadAll().catch(err => {
      console.error(err);
      setStatus("エラー: " + (err?.message ?? err));
    });
  </script>
</body>
</html>
