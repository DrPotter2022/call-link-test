<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>市場データ可視化（複数比較 / 指数化 / 円 / 円ベース / FRED）</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>

  <style>
    :root{
      --bg:#f5f7f6;
      --card:#ffffff;
      --text:#223;
      --muted:#667;
      --line:#dbe3df;
      --primary:#0b66d0;
      --ok:#0a7a2f;
      --ng:#b00020;
      --pill:#e8efea;
      --shadow: 0 6px 18px rgba(18,34,24,.08);
      --r:14px;
    }

    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic", Meiryo, sans-serif;
    }

    header{
      padding:14px 16px 8px;
      font-weight:700;
    }

    .wrap{
      max-width:1200px; margin:0 auto; padding:0 12px 24px;
    }

    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:var(--r); box-shadow:var(--shadow);
      padding:14px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }

    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;
    }

    label{font-size:12px; color:var(--muted); display:block; margin-bottom:6px;}
    input[type="date"], input[type="text"], select{
      width: 220px;
      max-width: 100%;
      padding:10px 10px;
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
      font-size:14px;
    }
    input[type="text"]{width:min(720px, 100%)}

    .btn{
      border:1px solid transparent;
      background:var(--primary);
      color:#fff;
      padding:10px 14px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      box-shadow: 0 4px 12px rgba(11,102,208,.22);
    }
    .btn:disabled{opacity:.55; cursor:not-allowed}
    .btn.secondary{
      background:#fff;
      color:var(--text);
      border-color:var(--line);
      box-shadow:none;
      font-weight:700;
    }
    .btn.ghost{
      background:#fff;
      border-color:var(--line);
      box-shadow:none;
      color:var(--text);
      font-weight:700;
    }

    .pill{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--pill);
      font-weight:800;
      font-size:12px;
      min-width:64px;
    }
    .pill.on{ color:var(--ok); border-color: rgba(10,122,47,.35); background: rgba(10,122,47,.08); }
    .pill.off{ color:var(--ng); border-color: rgba(176,0,32,.35); background: rgba(176,0,32,.08); }

    .hint{font-size:12px; color:var(--muted); line-height:1.45}
    .small{font-size:12px}
    .muted{color:var(--muted)}
    .divider{height:1px; background:var(--line); margin:12px 0}
    .sectionTitle{font-weight:800; margin:0 0 8px}

    .chkRow{display:flex; gap:14px; flex-wrap:wrap; align-items:center;}
    .chkRow label{margin:0; font-size:13px; color:var(--text); display:flex; gap:8px; align-items:center}
    .chkRow input{transform: translateY(1px);}

    .quickRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .qbtn{
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--line);
      background:#fff; cursor:pointer; font-weight:800;
    }

    /* Chart + table */
    .chartCard{padding:12px}
    #chartWrap{width:100%; overflow-x:auto;}
    canvas{max-width:100%;}
    .tableWrap{overflow:auto; border-radius:12px; border:1px solid var(--line);}
    table{
      border-collapse:collapse;
      width:100%;
      min-width: 820px;
      background:#fff;
    }
    thead th{
      position:sticky; top:0;
      background:#0a8;
      color:#fff;
      padding:10px 10px;
      text-align:left;
      font-size:12px;
      z-index:2;
      white-space:nowrap;
    }
    tbody td{
      padding:8px 10px;
      border-top:1px solid var(--line);
      font-size:12px;
      white-space:nowrap;
    }
    tbody tr:nth-child(even){background:#f7fbfa}

    .footerBtns{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:flex-end;
      margin-top:10px;
    }

    /* FX direction arrow */
    .fxBadge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      border:1px solid var(--line); background:#fff;
      font-weight:800;
    }
    .fxBadge .up{color:#b00020; font-weight:900; font-size:18px;}
    .fxBadge .down{color:#0a7a2f; font-weight:900; font-size:18px;}
    .fxBadge .txt{font-size:12px; color:var(--muted); font-weight:800;}
    .fxBadge .dir{min-width:22px; display:flex; justify-content:center;}

    /* Responsive tweaks */
    @media (min-width: 980px){
      .grid{grid-template-columns: 1fr;}
      input[type="date"], select{width: 240px}
    }
  </style>
</head>

<body>
  <header class="wrap">市場データ可視化（複数比較 / 指数化 / 円 / 円ベース / FRED）</header>

  <div class="wrap grid">

    <div class="card">
      <div class="row">
        <div>
          <label>開始日</label>
          <input id="dateStart" type="date" />
          <div class="quickRow" style="margin-top:8px">
            <button class="qbtn" id="btn1y">1年前</button>
            <button class="qbtn" id="btn3y">3年前</button>
            <button class="qbtn" id="btn5y">5年前</button>
            <button class="qbtn" id="btn10y">10年前</button>
          </div>
        </div>

        <div>
          <label>終了日</label>
          <input id="dateEnd" type="date" />
        </div>

        <div style="min-width: 280px; flex:1">
          <label>表示オプション</label>
          <div class="chkRow">
            <label><input id="chkIndex" type="checkbox" checked /> 初日=100（指数化）</label>
            <label><input id="chkFxDollar" type="checkbox" checked /> 為替データ（ドル円）を表示</label>
            <label><input id="chkUsdToJpy" type="checkbox" /> USD→円換算で表示</label>
          </div>
          <div class="hint" style="margin-top:6px">
            ※ USD→円換算ON時は内部的にUSDJPYを取得します（為替の表示は別設定）。
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <div>
          <label>銘柄①</label>
          <select id="sel1"></select>
        </div>
        <div>
          <label>銘柄②</label>
          <select id="sel2"></select>
        </div>
        <div>
          <label>銘柄③</label>
          <select id="sel3"></select>
        </div>

        <div style="flex:1; min-width: 280px">
          <label>手入力（任意）</label>
          <input id="txtManual" type="text" placeholder="例: aapl.us / 159A.jp / vnm.us / stw.au" />
          <div class="row" style="margin-top:8px">
            <button class="btn secondary" id="btnManual1">手入力を①へ</button>
            <button class="btn secondary" id="btnManual2">手入力を②へ</button>
            <button class="btn secondary" id="btnManual3">手入力を③へ</button>
          </div>
          <div class="hint" style="margin-top:6px">
            Stooq形式：米国 aapl.us、日本 1321.jp/159A.jp/348A.jp、豪州 stw.au 等。凡例クリックで表示ON/OFF（Chart.js標準）。
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row" style="align-items:flex-start;">
        <div style="flex:1; min-width: 280px">
          <div class="row" style="justify-content:space-between; align-items:center">
            <div class="sectionTitle">FRED（米日政策金利・GDP）</div>
            <div class="pill off" id="fredStatus">OFF</div>
          </div>
          <div class="hint">FRED API Key（入力すると自動で有効化）</div>
          <input id="fredKey" type="text" placeholder="（ここは空欄のまま）" value="" />
          <div class="chkRow" style="margin-top:10px">
            <label><input id="chkFREDAll" type="checkbox" checked /> FREDを追加（政策金利・GDP）</label>
          </div>
          <div class="hint" style="margin-top:6px">
            仕様：金利/GDPは日次に前方補完（発表月まで前回値）して表にも反映します。<br>
            米: FEDFUNDS / GDP、日: IRSTCI01JPM156N（短期金利代理） / JPNNGDP を使用。
          </div>
          <div class="chkRow" style="margin-top:10px">
            <label><input id="chkFF" type="checkbox" checked /> 米政策金利(FF)</label>
            <label><input id="chkUSGDP" type="checkbox" checked /> 米GDP</label>
            <label><input id="chkJPR" type="checkbox" checked /> 日本政策金利（代理）</label>
            <label><input id="chkJPGDP" type="checkbox" checked /> 日GDP</label>
          </div>
        </div>

        <div style="flex:1; min-width: 280px">
          <div class="row" style="justify-content:space-between; align-items:center">
            <div class="sectionTitle">PDF日本語フォント</div>
            <div class="pill off" id="fontStatus">未設定</div>
          </div>
          <div class="hint">TTFファイルを選択（保存され、次回以降も自動適用）</div>
          <div class="row" style="align-items:center">
            <input id="fontFile" type="file" accept=".ttf" />
            <div class="pill off" id="fontName" style="min-width:220px">未設定</div>
            <button class="btn secondary" id="btnFontClear">フォント消去</button>
          </div>
          <div class="hint" style="margin-top:6px">※ PDF出力時のみ使用。未設定でもXLSX出力は可能。</div>
        </div>
      </div>

      <div class="divider"></div>

      <!-- Buttons between PDF font and graph -->
      <div class="row" style="align-items:center; justify-content:space-between">
        <div class="row" style="align-items:center">
          <button class="btn" id="btnFetch">取得＆表示</button>
          <button class="btn secondary" id="btnFxFlip">為替反転↑</button>
          <div class="fxBadge" title="為替反転時：円安が上なら↑（赤太字）、円安が下なら↓（緑太字）">
            <div class="dir" id="fxDir"><span class="up">↑</span></div>
            <div class="txt" id="fxTxt">円安が上 / 円高が下</div>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <!-- Chart + table must be at bottom -->
      <div class="card chartCard" style="margin-top:10px; padding:0; box-shadow:none; border:none; background:transparent">
        <div class="card chartCard" style="margin:0">
          <div id="chartWrap">
            <canvas id="chart" height="140"></canvas>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="tableWrap">
            <table id="tbl">
              <thead><tr id="tblHead"></tr></thead>
              <tbody id="tblBody"></tbody>
            </table>
          </div>

          <div class="footerBtns">
            <button class="btn secondary" id="btnXlsx">XLSX出力</button>
            <button class="btn secondary" id="btnPdf">PDF出力</button>
          </div>

          <div class="hint" style="margin-top:10px">
            凡例クリックで表示ON/OFF（Chart.js標準）。<br>
            FREDはAPIキー必須。Stooq/為替/指数はプロキシ経由で取得します。
          </div>
        </div>
      </div>
    </div>

  </div>

<script>
/* ==========================================================
  Settings
========================================================== */
const PROXY_BASE = "https://market-proxy.withover-re.workers.dev/?url="; // CORS回避（Stooq / FRED / そのほか）
const DEFAULTS = [
  {label:"S&P500（SPY）", code:"spy.us"},
  {label:"NASDAQ100（QQQ）", code:"qqq.us"},
  {label:"日経平均225（1321）", code:"1321.jp"},
  {label:"欧州株ETF（VGK）", code:"vgk.us"},
  {label:"全米株式ETF（VTI）", code:"vti.us"},
  {label:"新興国ETF（VWO）", code:"vwo.us"},
  {label:"金（GLD）", code:"gld.us"},
  {label:"米10年国債ETF（IEF）", code:"ief.us"},
];

/* ==========================================================
  DOM
========================================================== */
const dateStartEl = document.getElementById("dateStart");
const dateEndEl   = document.getElementById("dateEnd");
const sel1 = document.getElementById("sel1");
const sel2 = document.getElementById("sel2");
const sel3 = document.getElementById("sel3");

const txtManual = document.getElementById("txtManual");
const btnManual1 = document.getElementById("btnManual1");
const btnManual2 = document.getElementById("btnManual2");
const btnManual3 = document.getElementById("btnManual3");

const chkIndex = document.getElementById("chkIndex");
const chkFxDollar = document.getElementById("chkFxDollar");
const chkUsdToJpy = document.getElementById("chkUsdToJpy");

const btnFetch = document.getElementById("btnFetch");
const btnFxFlip = document.getElementById("btnFxFlip");
const fxDirEl = document.getElementById("fxDir");
const fxTxtEl = document.getElementById("fxTxt");

const btnXlsx = document.getElementById("btnXlsx");
const btnPdf  = document.getElementById("btnPdf");

const fredKeyEl = document.getElementById("fredKey");
const fredStatusEl = document.getElementById("fredStatus");
const chkFREDAll = document.getElementById("chkFREDAll");
const chkFF = document.getElementById("chkFF");
const chkUSGDP = document.getElementById("chkUSGDP");
const chkJPR = document.getElementById("chkJPR");
const chkJPGDP = document.getElementById("chkJPGDP");

const fontFile = document.getElementById("fontFile");
const fontStatusEl = document.getElementById("fontStatus");
const fontNameEl = document.getElementById("fontName");
const btnFontClear = document.getElementById("btnFontClear");

// ---------- Status / Setup helpers ----------
const APP_STATE = {
  fredKeyValid: false,
  lastFredKeyChecked: "",
};

function setStatusPill(pillEl, isOn, onText="ON", offText="OFF") {
  if (!pillEl) return;
  pillEl.textContent = isOn ? onText : offText;
  pillEl.classList.toggle("on", !!isOn);
  pillEl.classList.toggle("off", !isOn);
}

function debounce(fn, wait=400) {
  let t = null;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

async function refreshFredStatus({validate=false}={}) {
  const key = (fredKeyEl?.value || "").trim();
  if (!key) {
    APP_STATE.fredKeyValid = false;
    APP_STATE.lastFredKeyChecked = "";
    setStatusPill(fredStatusEl, false);
    return;
  }
  // 入力があれば一旦ON（色）にする。必要なら軽く検証する
  if (!validate) {
    setStatusPill(fredStatusEl, true);
    return;
  }
  if (APP_STATE.lastFredKeyChecked === key && APP_STATE.fredKeyValid) {
    setStatusPill(fredStatusEl, true);
    return;
  }
  try {
    // 最小限の検証：FEDFUNDSを1点だけ取れるか
    const today = new Date().toISOString().slice(0,10);
    const start = new Date(Date.now() - 1000*60*60*24*30).toISOString().slice(0,10);
    const obs = await fetchFREDSeries("FEDFUNDS", start, today, key);
    APP_STATE.fredKeyValid = Array.isArray(obs) && obs.length > 0;
    APP_STATE.lastFredKeyChecked = key;
    setStatusPill(fredStatusEl, APP_STATE.fredKeyValid);
  } catch (e) {
    APP_STATE.fredKeyValid = false;
    APP_STATE.lastFredKeyChecked = key;
    setStatusPill(fredStatusEl, false);
  }
}

async function refreshFontStatus() {
  try {
    const v = await idbGet("pdf_font_blob");
    const ok = !!v;
    setStatusPill(fontStatusEl, ok, "設定済", "未設定");
    return ok;
  } catch (e) {
    setStatusPill(fontStatusEl, false, "設定済", "未設定");
    return false;
  }
}

const onFredKeyInput = debounce(async () => {
  await refreshFredStatus({validate:true});
}, 450);

if (fredKeyEl) {
  fredKeyEl.addEventListener("input", () => {
    refreshFredStatus({validate:false});
    onFredKeyInput();
  });
}

// 起動時ステータス
setTimeout(() => {
  refreshFredStatus({validate:false});
  refreshFontStatus();
}, 0);

/* ==========================================================
  Utility
========================================================== */
function alertErr(msg){
  alert("このページの内容\n\n" + msg);
}

function ymd(d){
  const dt = new Date(d);
  if (Number.isNaN(dt.getTime())) return "";
  const y=dt.getFullYear();
  const m=String(dt.getMonth()+1).padStart(2,"0");
  const dd=String(dt.getDate()).padStart(2,"0");
  return `${y}-${m}-${dd}`;
}

function addYears(dateStr, years){
  const dt = new Date(dateStr);
  dt.setFullYear(dt.getFullYear()+years);
  return ymd(dt);
}

function minusYears(dateStr, years){
  const dt = new Date(dateStr);
  dt.setFullYear(dt.getFullYear()-years);
  return ymd(dt);
}

function clampNum(x){
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

function proxyUrl(url){
  return PROXY_BASE + encodeURIComponent(url);
}

async function fetchText(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return await res.text();
}

async function fetchJson(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return await res.json();
}

/* ==========================================================
  IndexedDB (font)
========================================================== */
const IDB_NAME = "that_time_db_v1";
const IDB_STORE = "kv";

function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(IDB_NAME, 1);
    req.onupgradeneeded = (ev)=>{
      const db = req.result;
      if(!db.objectStoreNames.contains(IDB_STORE)){
        db.createObjectStore(IDB_STORE);
      }
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}

async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(IDB_STORE,"readonly");
    const st = tx.objectStore(IDB_STORE);
    const req = st.get(key);
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}

async function idbSet(key,val){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(IDB_STORE,"readwrite");
    const st = tx.objectStore(IDB_STORE);
    const req = st.put(val, key);
    req.onsuccess = ()=> resolve(true);
    req.onerror = ()=> reject(req.error);
  });
}

async function idbDel(key){
  const db = await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(IDB_STORE,"readwrite");
    const st = tx.objectStore(IDB_STORE);
    const req = st.delete(key);
    req.onsuccess = ()=> resolve(true);
    req.onerror = ()=> reject(req.error);
  });
}

async function refreshFontState() {
  const pill = fontStatusEl;
  try {
    const blob = await idbGet("pdf_font_blob");
    const name = await idbGet("pdf_font_name");
    const ok = !!blob;
    if (pill) {
      pill.textContent = ok ? "設定済" : "未設定";
      pill.classList.toggle("on", ok);
      pill.classList.toggle("off", !ok);
    }
    // UI: ファイル名表示
    if (fontNameEl) {
      fontNameEl.textContent = ok ? (name || "（保存済み）") : "未設定";
      fontNameEl.classList.toggle("on", ok);
      fontNameEl.classList.toggle("off", !ok);
    }
    return ok;
  } catch (e) {
    if (pill) {
      pill.textContent = "未設定";
      pill.classList.remove("on");
      pill.classList.add("off");
    }
    if (fontNameEl) {
      fontNameEl.textContent = "未設定";
      fontNameEl.classList.remove("on");
      fontNameEl.classList.add("off");
    }
    return false;
  }
}

/* ==========================================================
  Data Fetch (Stooq)
========================================================== */
function stooqCsvUrl(symbol){
  // Stooq daily history CSV: https://stooq.com/q/d/l/?s=spy.us&i=d
  return `https://stooq.com/q/d/l/?s=${encodeURIComponent(symbol)}&i=d`;
}

async function fetchStooqDailyCSV(symbol){
  const url = proxyUrl(stooqCsvUrl(symbol));
  const csv = await fetchText(url);
  if(!csv || csv.trim().split("\n").length < 2){
    throw new Error(`Stooq CSVが空です(${symbol})`);
  }
  return csv;
}

function parseStooqCSV(csv){
  // Date,Open,High,Low,Close,Volume
  const lines = csv.trim().split(/\r?\n/);
  const out = [];
  for(let i=1;i<lines.length;i++){
    const parts = lines[i].split(",");
    if(parts.length < 5) continue;
    const d = parts[0];
    const close = clampNum(parts[4]);
    if(!d || close===null) continue;
    out.push({date:d, value:close});
  }
  return out;
}

/* ==========================================================
  Data Fetch (FRED via proxy)
========================================================== */
async function fetchFREDSeries(seriesId, start, end, apiKey){
  const u = new URL("https://api.stlouisfed.org/fred/series/observations");
  u.searchParams.set("series_id", seriesId);
  u.searchParams.set("api_key", apiKey);
  u.searchParams.set("file_type", "json");
  u.searchParams.set("observation_start", start);
  u.searchParams.set("observation_end", end);

  const json = await fetchJson(proxyUrl(u.toString()));
  const obs = json?.observations || [];
  const out = [];
  for(const r of obs){
    const v = clampNum(r.value);
    if(!r.date || v===null) continue;
    out.push({date:r.date, value:v});
  }
  return out;
}

/* ==========================================================
  Merge / Fill
========================================================== */
function buildDateMap(seriesArr){
  const map = new Map();
  for(const s of seriesArr){
    for(const r of s.data){
      if(!map.has(r.date)) map.set(r.date, {});
      map.get(r.date)[s.key] = r.value;
    }
  }
  return map;
}

function dateRange(start, end){
  const out=[];
  const s = new Date(start);
  const e = new Date(end);
  for(let d=new Date(s); d<=e; d.setDate(d.getDate()+1)){
    out.push(ymd(d));
  }
  return out;
}

// forward-fill within range
function forwardFillRows(rows, keys){
  const last = {};
  for(const k of keys) last[k] = null;
  for(const row of rows){
    for(const k of keys){
      if(row[k]!==undefined && row[k]!==null){
        last[k] = row[k];
      }else if(last[k]!==null){
        row[k] = last[k];
      }else{
        row[k] = null;
      }
    }
  }
  return rows;
}

/* ==========================================================
  Chart / Table
========================================================== */
let chart = null;
let fxInverted = false;

const COLOR_MAP = {
  "s1":"#1f77b4", // blue
  "s2":"#ff4f7a", // pink/red
  "s3":"#ff8c00", // orange
  "usd":"#f5b000", // yellow-ish
  "ff":"#7b61ff",  // violet
  "usgdp":"#00bcd4", // cyan
  "jpr":"#2ecc71", // green
  "jpgdp":"#8e44ad" // purple
};

function setFxBadge(){
  if(!fxInverted){
    fxDirEl.innerHTML = '<span class="up">↑</span>';
    fxTxtEl.textContent = "円安が上 / 円高が下";
  }else{
    fxDirEl.innerHTML = '<span class="down">↓</span>';
    fxTxtEl.textContent = "円安が下 / 円高が上";
  }
}

function toIndex100(series){
  if(series.length===0) return series;
  const base = series.find(r=>r.value!=null)?.value ?? null;
  if(base===null || base===0) return series.map(r=>({...r, idx:null}));
  return series.map(r=>{
    if(r.value==null) return {...r, idx:null};
    return {...r, idx: (r.value/base)*100 };
  });
}

function buildChart(labels, datasets){
  const ctx = document.getElementById("chart").getContext("2d");
  if(chart){ chart.destroy(); chart=null; }

  chart = new Chart(ctx,{
    type:"line",
    data:{ labels, datasets },
    options:{
      responsive:true,
      interaction:{ mode:"index", intersect:false },
      plugins:{
        legend:{ position:"top" },
        tooltip:{
          callbacks:{
            label:(ctx)=>{
              const ds = ctx.dataset;
              const raw = ds._rawMap ? ds._rawMap[ctx.dataIndex] : null;
              const v = ctx.parsed.y;
              if(ds._displayRaw && raw!=null){
                // raw表示（FFなどは%）
                const suffix = ds._rawSuffix || "";
                return `${ds.label}: ${raw}${suffix}`;
              }
              return `${ds.label}: ${Number.isFinite(v)? v.toFixed(3): ""}`;
            }
          }
        }
      },
      scales:{
        y:{ title:{display:true, text: chkIndex.checked ? "INDEX（初日=100）" : "Value" } },
        y2:{
          position:"right",
          grid:{ drawOnChartArea:false },
          title:{display:true, text:"USDJPY"},
          reverse: fxInverted,  // 反転
        }
      }
    }
  });
}

function renderTable(rows, columns){
  const head = document.getElementById("tblHead");
  const body = document.getElementById("tblBody");
  head.innerHTML = "";
  body.innerHTML = "";

  for(const c of columns){
    const th = document.createElement("th");
    th.textContent = c.label;
    head.appendChild(th);
  }

  for(const r of rows){
    const tr = document.createElement("tr");
    for(const c of columns){
      const td = document.createElement("td");
      const v = r[c.key];
      td.textContent = (v==null || v===undefined) ? "" : (typeof v==="number" ? (Number.isInteger(v)? v.toString() : v.toFixed(6)) : v);
      tr.appendChild(td);
    }
    body.appendChild(tr);
  }
}

/* ==========================================================
  Main build
========================================================== */
async function run(){
  try{
    btnFetch.disabled = true;

    const start = dateStartEl.value;
    const end = dateEndEl.value;
    if(!start || !end) throw new Error("開始日と終了日を指定してください。");

    const s1 = sel1.value;
    const s2 = sel2.value;
    const s3 = sel3.value;

    const wantsFx = chkFxDollar.checked || chkUsdToJpy.checked;

    // Fetch stock/ETF indices (Stooq)
    const seriesList = [];
    const stooqSymbols = [
      {key:"s1", label: sel1.options[sel1.selectedIndex]?.textContent || "銘柄①", code:s1},
      {key:"s2", label: sel2.options[sel2.selectedIndex]?.textContent || "銘柄②", code:s2},
      {key:"s3", label: sel3.options[sel3.selectedIndex]?.textContent || "銘柄③", code:s3},
    ].filter(x=>x.code);

    for(const it of stooqSymbols){
      const csv = await fetchStooqDailyCSV(it.code);
      const data = parseStooqCSV(csv).filter(r=>r.date>=start && r.date<=end);
      seriesList.push({key:it.key, label:it.label, data, axis:"y"});
    }

    // FX (USDJPY)
    if(wantsFx){
      const csv = await fetchStooqDailyCSV("usd/jpy");
      const data = parseStooqCSV(csv).filter(r=>r.date>=start && r.date<=end);
      seriesList.push({key:"usd", label:"USDJPY", data, axis:"y2"});
    }

    // FRED
    const apiKey = (fredKeyEl.value || "").trim();
    if(chkFREDAll.checked){
      if(!apiKey){
        throw new Error("FRED APIキーが未入力です。");
      }

      const tasks = [];
      const add = (checked, sid, key, label)=> {
        if(!checked) return;
        tasks.push(
          fetchFREDSeries(sid, start, end, apiKey).then(data=>({sid,key,label,data}))
        );
      };

      add(chkFF.checked, "FEDFUNDS", "ff", "米政策金利(FF)");
      add(chkUSGDP.checked, "GDP", "usgdp", "米GDP");
      add(chkJPR.checked, "IRSTCI01JPM156N", "jpr", "日本政策金利（代理）");
      add(chkJPGDP.checked, "JPNNGDP", "jpgdp", "日GDP");

      const got = await Promise.all(tasks);
      for(const g of got){
        seriesList.push({key:g.key, label:g.label, data:g.data, axis:"y"});
      }
    }

    // merge to daily rows
    const allDates = dateRange(start, end);
    const map = buildDateMap(seriesList);
    const rows = allDates.map(d=> ({Date:d, ... (map.get(d)||{})}));

    // forward fill for any missing series
    const fillKeys = seriesList.map(s=>s.key);
    forwardFillRows(rows, fillKeys);

    // detect columns that have at least one number (avoid "全列欠損"誤判定)
    const visibleKeys = fillKeys.filter(k => rows.some(r => typeof r[k]==="number" && Number.isFinite(r[k])));
    if(visibleKeys.length===0){
      throw new Error("全ての列に欠損があり、表示できる列がありません（期間を短くする・銘柄を変える等が必要です）");
    }

    // Index transform if checked (except USDJPY still on y2 but can be indexed too for comparison if desired)
    const labels = rows.map(r=>r.Date);

    const datasets = [];
    const columns = [{key:"Date", label:"Date"}];

    // Build indexed series maps for chart (y axis)
    for(const s of seriesList){
      if(!visibleKeys.includes(s.key)) continue;

      // For chart series values
      let yValues = rows.map(r => r[s.key]);
      let rawMap = null;
      let displayRaw = false;
      let rawSuffix = "";

      // For FX axis direction
      const yAxis = (s.axis==="y2") ? "y2" : "y";

      // If index
      if(chkIndex.checked && s.axis!=="y2"){
        // keep raw for tooltip if it's rate or gdp
        rawMap = yValues.map(v=>v==null? null : v);
        displayRaw = (s.key==="ff" || s.key==="jpr" || s.key==="usgdp" || s.key==="jpgdp");
        rawSuffix = (s.key==="ff" || s.key==="jpr") ? " %" : "";
        // compute index base
        const base = yValues.find(v=>v!=null);
        yValues = yValues.map(v => (base && v!=null) ? (v/base)*100 : null);
      }else{
        // not index: still display raw
        rawMap = yValues.map(v=>v==null? null : v);
        displayRaw = (s.key==="ff" || s.key==="jpr");
        rawSuffix = (s.key==="ff" || s.key==="jpr") ? " %" : "";
      }

      const color = COLOR_MAP[s.key] || undefined;

      datasets.push({
        label: s.label,
        data: yValues,
        borderColor: color,
        backgroundColor: color,
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.15,
        yAxisID: yAxis,
        _rawMap: rawMap,
        _displayRaw: displayRaw,
        _rawSuffix: rawSuffix,
      });

      columns.push({key:s.key, label:s.label});
    }

    // Render chart and table
    buildChart(labels, datasets);

    // table: if index checked, show index for stooq, but for FRED show raw (you requested: table filled to release month)
    // Here: rows already raw, but if index checked, we prefer:
    // - stooq series: index values
    // - fred series: raw values
    const tableRows = rows.map(r=>{
      const o = {Date:r.Date};
      for(const s of seriesList){
        if(!visibleKeys.includes(s.key)) continue;
        const v = r[s.key];
        if(chkIndex.checked && s.axis!=="y2" && !["ff","jpr","usgdp","jpgdp"].includes(s.key)){
          // stooq index
          const base = rows.find(rr=>rr[s.key]!=null)?.[s.key];
          o[s.key] = (base && v!=null) ? (v/base)*100 : null;
        }else{
          o[s.key] = v;
        }
      }
      return o;
    });

    renderTable(tableRows, columns);
  }catch(e){
    console.error(e);
    alertErr(e.message || String(e));
  }finally{
    btnFetch.disabled = false;
  }
}

/* ==========================================================
  XLSX / PDF
========================================================== */
function tableToSheet(){
  const tbl = document.getElementById("tbl");
  const ws = XLSX.utils.table_to_sheet(tbl);
  return ws;
}

btnXlsx.addEventListener("click", ()=>{
  try{
    const wb = XLSX.utils.book_new();
    const ws = tableToSheet();
    XLSX.utils.book_append_sheet(wb, ws, "data");
    XLSX.writeFile(wb, "market_data.xlsx");
  }catch(e){
    console.error(e);
    alertErr("XLSX出力に失敗しました。");
  }
});

btnPdf.addEventListener("click", async ()=>{
  try{
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({orientation:"landscape", unit:"pt", format:"a4"});
    doc.setFontSize(12);
    doc.text("市場データ可視化", 40, 40);

    // table
    const head = [];
    const body = [];
    const ths = [...document.querySelectorAll("#tblHead th")].map(th=>th.textContent);
    head.push(ths);
    const trs = [...document.querySelectorAll("#tblBody tr")];
    for(const tr of trs){
      const tds = [...tr.querySelectorAll("td")].map(td=>td.textContent);
      body.push(tds);
    }

    doc.autoTable({
      head, body,
      startY: 60,
      styles:{ fontSize:8, cellPadding:3 }
    });

    doc.save("market_data.pdf");
  }catch(e){
    console.error(e);
    alertErr("PDF出力に失敗しました。");
  }
});

/* ==========================================================
  Init
========================================================== */
function fillSelect(sel){
  sel.innerHTML = "";
  for(const d of DEFAULTS){
    const opt = document.createElement("option");
    opt.value = d.code;
    opt.textContent = d.label;
    sel.appendChild(opt);
  }
}

function setDefaultDates(){
  const today = new Date();
  const end = ymd(today);
  const start = ymd(new Date(today.getTime() - 1000*60*60*24*365));
  dateStartEl.value = start;
  dateEndEl.value = end;
}

function setManualToSelect(sel){
  const v = (txtManual.value || "").trim();
  if(!v) return;
  // If value already in options, select it; else append
  const lower = v.toLowerCase();
  const exists = [...sel.options].some(o => o.value.toLowerCase()===lower);
  if(!exists){
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = `手入力: ${v}`;
    sel.insertBefore(opt, sel.firstChild);
  }
  sel.value = v;
}

btnManual1.addEventListener("click", ()=> setManualToSelect(sel1));
btnManual2.addEventListener("click", ()=> setManualToSelect(sel2));
btnManual3.addEventListener("click", ()=> setManualToSelect(sel3));

btnFetch.addEventListener("click", run);

btnFxFlip.addEventListener("click", ()=>{
  fxInverted = !fxInverted;
  setFxBadge();
  if(chart){
    chart.options.scales.y2.reverse = fxInverted;
    chart.update();
  }
});

document.getElementById("btn1y").addEventListener("click", ()=>{
  dateStartEl.value = minusYears(dateEndEl.value,1);
});
document.getElementById("btn3y").addEventListener("click", ()=>{
  dateStartEl.value = minusYears(dateEndEl.value,3);
});
document.getElementById("btn5y").addEventListener("click", ()=>{
  dateStartEl.value = minusYears(dateEndEl.value,5);
});
document.getElementById("btn10y").addEventListener("click", ()=>{
  dateStartEl.value = minusYears(dateEndEl.value,10);
});

btnFontClear.addEventListener("click", async ()=>{
  try{
    await idbDel("pdf_font_blob");
    await idbDel("pdf_font_name");
    await refreshFontState();
  }catch(e){
    console.error(e);
    alertErr("フォント消去に失敗しました。");
  }
});

fontFile.addEventListener("change", async () => {
  const f = fontFile.files?.[0];
  if (!f) { await refreshFontState(); return; }
  try {
    const buf = await f.arrayBuffer();
    await idbSet("pdf_font_blob", new Blob([buf], { type: "font/ttf" }));
    await idbSet("pdf_font_name", f.name);
    await refreshFontState();
  } catch (e) {
    console.warn(e);
    await refreshFontState();
    alertErr("フォント読み込みに失敗しました。別のTTFでお試しください。");
  }
});

(function init(){
  fillSelect(sel1); fillSelect(sel2); fillSelect(sel3);
  sel1.selectedIndex = 0;
  sel2.selectedIndex = 3 < sel2.options.length ? 3 : 1;
  sel3.selectedIndex = 2 < sel3.options.length ? 2 : 2;

  setDefaultDates();
  setFxBadge();
  refreshFontState();
  refreshFredStatus({validate:false});
})();
</script>

</body>
</html>
